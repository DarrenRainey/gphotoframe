#!/usr/bin/python
#
# gphotoframe - Photo Frame for the GNOME Desktop.

from twisted.internet import gtk2reactor
gtk2reactor.install()
from twisted.internet import defer, reactor
from twisted.web      import client

import gtk
import gtk.glade
import glib
import gobject
import gconf
import sqlite3
import urllib
import os, sys, time
import simplejson as json
import random
import bisect
import re

VERSION = 0.02

class Glade(object):
    glade_dir = os.path.dirname(os.path.abspath(__file__))
    glade_file = glade_dir + '/gphotoframe.glade'

class PhotoFrame(object):
    """Photo Frame"""

    def __init__(self):

        self.gui = gtk.glade.XML(Glade.glade_file)
        self.image = self.gui.get_widget('image1')
        self.window = window = self.gui.get_widget('window1')
        window.set_decorated(False)
        window.set_skip_taskbar_hint(True)
        window.set_gravity(gtk.gdk.GRAVITY_CENTER)
        window.move(gconfc.get_int('root_x'), gconfc.get_int('root_y'))
        window.resize(1, 1)
        window.show_all()
        window.get_position()

        preferences = Preferences()

        self.dic = { 
            "on_window1_button_press_event" : self.check_button,
            "on_window1_leave_notify_event" : self.save_geometry,
            "on_window1_destroy" : self.quit,

            "on_menuitem5_activate" : self.open_photo,
            "on_prefs" : preferences.start,
            "on_about" : self.about,
            "on_quit"  : self.quit,
            }
        self.gui.signal_autoconnect(self.dic)

    def quit(self, widget):
        reactor.stop()

    def check_button(self, widget, event):
        if event.button == 1:
            widget.begin_move_drag \
                (event.button, int(event.x_root), int(event.y_root), event.time)
        elif event.button == 2:
            pass
        elif event.button == 3:
            self.popup_menu(widget, event)

    def popup_menu(self, widget, event):
        menu = self.gui.get_widget('menu1')
        menu.popup(None, None, None, event.button, event.time)
    
    def open_photo(self, widget):
        url = self.photo_now['page_url'] \
            if self.photo_now.has_key('page_url') else self.photo_now['url']
        os.system('gnome-open ' + url)

    def about(self, widget):
        gui = gtk.glade.XML(Glade.glade_file)
        about = gui.get_widget('aboutdialog')
        about.set_property('version', VERSION)
        about.run()
        about.destroy()

    def save_geometry(self, widget, event):
        if event.mode != 2:
            return True

        x, y = widget.get_position()
        w, h = widget.get_size()
        gconfc.set_int( 'root_x', x + w / 2);
        gconfc.set_int( 'root_y', y + h / 2);
        return False
    
    def set_image(self, pixbuf):
        w = pixbuf.get_width()
        h = pixbuf.get_height()

        self.image.set_from_pixbuf(pixbuf)
        self.set_border(w, h)

        tip = self.photo_now.get('title')
        if self.photo_now.get('owner_name') != None:
            tip = tip + "\nby " + self.photo_now.get('owner_name')
        self.window.set_tooltip_markup(tip) 

    def set_blank_image(self):
        w = gconfc.get_int('max_width', 400)
        h = gconfc.get_int('max_height', 300)

        pixmap = gtk.gdk.Pixmap(self.window.window, w, h, -1)
        colormap = gtk.gdk.colormap_get_system()
        color = colormap.alloc_color(0, 0, 0)
        gc = gtk.gdk.Drawable.new_gc(pixmap)
        gc.set_foreground(color)
        pixmap.draw_rectangle(gc, True, 0,0,400,300)

        self.image.set_from_pixmap(pixmap, None)
        self.set_border(w, h)

    def set_border(self, w, h):
        border = gconfc.get_int('border_width', 10)
        self.window.resize(w + border, h + border)


######################################################################

class Preferences(object):
    """Preferences"""

    def start(self, widget):
        self.gui = gtk.glade.XML(Glade.glade_file)
        self.prefs = self.gui.get_widget('preferences')
        self.spinbutton1 = self.gui.get_widget('spinbutton1')
        val = gconfc.get_int('interval', 30)
        self.spinbutton1.set_value(val)

        api_key = gconfc.get_string('flickr/api_key')
        user_id = gconfc.get_string('flickr/user_id')
        self.entry1 = self.gui.get_widget('entry1')
        self.entry2 = self.gui.get_widget('entry2')

        if api_key != None:
            self.entry1.set_text(api_key)
        if user_id != None:
            self.entry2.set_text(user_id)

        self.preference_list = PreferencesList(self.gui)
        self.prefs.show_all()

        dic = { 
            "on_close_button" : self.close,
            "on_spinbutton1_value_changed" : self.interval_changed,
            "on_entry1_editing_done"       : self.interval_changed,
            "on_quit"         : gtk.main_quit }
        self.gui.signal_autoconnect(dic)

    def interval_changed(self, widget):
        val = self.spinbutton1.get_value_as_int()
        gconfc.set_int( 'interval', val);

    def close(self, widget):
        flickr_api_key = self.entry1.get_text()
        flickr_user_id = self.entry2.get_text()
        gconfc.set_string( 'flickr/api_key', flickr_api_key );
        gconfc.set_string( 'flickr/user_id', flickr_user_id );

        self.preference_list.save_all_data()
        self.prefs.destroy()

class PreferencesList(object):
    """Preferences Photo Source List"""

    def __init__(self, gui):
        self.treeview = gui.get_widget("treeview1")

        self.add_column("Source", 0)
        self.add_column("Option", 1)
        self.add_column("Weight", 2)
	
        self.source_list = photoliststore.list
        self.treeview.set_model(self.source_list)

        dic = { 
            "on_button3_clicked" : self.new_button,
            "on_button4_clicked" : self.prefs_button,
            "on_button5_clicked" : self.delete_button,
            }
        gui.signal_autoconnect(dic)

    def add_column(self, title, id):
        column = gtk.TreeViewColumn(title, gtk.CellRendererText(), text=id)
        column.set_resizable(True)
        column.set_sort_column_id(id)
        self.treeview.append_column(column)

    def new_button(self, widget):
        photodialog = PhotoDialog();  
        (result, v) = photodialog.run()

        if result == 1:
            photoliststore.append(v)

    def prefs_button(self, widget):
        treeselection = self.treeview.get_selection()
        (model, iter) = treeselection.get_selected()

        photodialog = PhotoDialog(model[iter]);  
        (result, v) = photodialog.run()

        if result == 1:
            photoliststore.append(v, iter)
            self.source_list.remove(iter)

    def delete_button(self, widget):
        treeselection = self.treeview.get_selection()
        (model, iter) = treeselection.get_selected()
        self.source_list.remove(iter)

    def save_all_data(self):
        model = self.treeview.get_model()
        gconfc.recursive_unset('sources')

        for i, row in enumerate(model):
            data = {}
            for num, v in enumerate(('source', 'target', 'priority')):
                data[v] = row[num]

            for k, v in data.iteritems():
                key = 'sources/%s/%s' % (i, k)
                value = v if v != None else ""
                if isinstance(value, int):
                    gconfc.set_int( key, value );
                else:
                    gconfc.set_string( key, value );

class PhotoDialog():
    """Photo Source Dialog"""

    def __init__(self, data=None):
        self.gui = gtk.glade.XML(Glade.glade_file)
        self.photo = {}
        self.widget = None
        self.data = data

    def run(self):
        self.dialog = self.gui.get_widget('photo_source')

        # source
        dm = {'Folder' : 0, 'F-Spot' : 1, 'Flickr' : 2}
        source_num = dm[self.data[0]] if self.data != None else 0
        self.photo['source'] = self.gui.get_widget('combobox4')
        self.photo['source'].set_active(source_num)

        # target
        self.change_combobox(self.photo['source'], self.data)

        # weight
        weight = self.data[2] if self.data != None else 0
        self.photo['weight'] = self.gui.get_widget('spinbutton3')
        self.photo['weight'].set_value(weight)

        dic = { "on_combobox4_changed" : self.change_combobox }
        self.gui.signal_autoconnect(dic)
        self.result = self.dialog.run()

        target = self.photo['target'].get_current_folder() \
            if isinstance(self.photo['target'], gtk.FileChooserButton) \
            else  self.photo['target'].get_active_text()
        v = [ self.photo['source'].get_active_text(),
              target, 
              self.photo['weight'].get_value() ]

        self.dialog.destroy()
        return self.result, v

    def change_combobox(self, combobox, data=None):
        text = combobox.get_active_text()
        token = { 'Folder' : PhotoTargetDir,
                  'F-Spot' : PhotoTargetFspot,
                  'Flickr' : PhotoTargetFlickr }
        old_widget = self.photo.get('target')
        self.photo['target'] = token[text](self.gui, old_widget, data).make()

class PhotoTarget(object):
    def __init__(self, gui, old_widget=None, data=None):
        self.gui = gui
        self.table = gui.get_widget('table4')
        if old_widget != None:
            self.table.remove(old_widget)
        self.data = data

    def make(self, data=None):
        self.constract()
        self.attach()
        if self.data != None:
            self.set_default()
        return self.new_widget

    def constract(self):
        self.new_widget = gtk.combo_box_new_text()
        for text in self.label():
            self.new_widget.append_text(text)
        self.new_widget.set_active(0)

    def attach(self):
        self.new_widget.show()
        self.table.attach(self.new_widget, 1, 2, 1, 2, xpadding=0, ypadding=0)

    def set_default(self):
        pass
        
class PhotoTargetFlickr(PhotoTarget):
    def label(self):
        return  ['flickr.interestingness.getList',
                 'flickr.favorites.getPublicList',
                 'flickr.photos.getContactsPublicPhotos', ]

    def set_default(self):
        fr_num = self.label().index(self.data[1])
        self.new_widget.set_active(fr_num)

class PhotoTargetFspot(PhotoTarget):
    def label(self):
        return ('', )

class PhotoTargetDir(PhotoTarget):
    def constract(self):
        self.new_widget = gtk.FileChooserButton("button")
        self.new_widget.set_action(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)

    def set_default(self):
        self.new_widget.set_current_folder(self.data[1])

######################################################################

class PhotoListStore():
    """list"""

    def __init__(self):
        self.token = { 
            'Folder' : MakeDirPhoto,
            'F-Spot' : MakeFSpotPhoto,
            'Flickr' : MakeFlickrPhoto }
        self.list = gtk.ListStore(str, str, int, object)

        for dir in gconfc.all_dirs('sources'):
            data = {}

            for e in gconfc.all_entries(dir):
                if e.get_value() == None:
                    break

                if e.get_value().type == gconf.VALUE_INT:
                    value = e.get_value().get_int()
                else:
                    value = e.get_value().get_string()

                path = e.get_key()
                key = path[ path.rfind('/') + 1: ]
                data[key] = value
            else:
                self.append([data['source'], data['target'], data['priority']])

        self.timer()

    def append(self, v, i=None):
        obj = self.token[ v[0] ]( v[1], v[2] )
        v.append(obj)
        self.list.insert_before(i, v)
        obj.prepare()

    def timer(self):
        self.change_photo()
        self.interval = gconfc.get_int('interval', 30)
        gobject.timeout_add( self.interval * 1000, self.timer )
        return False

    def change_photo(self):
        target_list = [ x[3] for x in self.list if len( x[3].photos ) > 0 ]
        if len(target_list) > 0:
            target = WeightedRandom(target_list)
            target().get_photo()
        else:
            main.set_blank_image()
        return True

class MakePhoto(object):
    """Photo Factory"""

    def __init__(self, method, weight):
        self.weight = weight
        self.method = method
        self.total  = 0
        self.photos = []

    def make(self, *args):
        if self.photo.has_key('rate'):
            print self.photo['rate'],
        print self.photo['url']
        try:
            self.pixbuf = gtk.gdk.pixbuf_new_from_file(self.photo['filename'])
            orientation = self.pixbuf.get_option('orientation')
            self.rotate(orientation)
            self.scale()
            main.photo_now = self.photo
            main.set_image(self.pixbuf)
        except glib.GError:
            print sys.exc_info()[1]

    def scale(self):
        max_w = float( gconfc.get_int('max_width', 400) )
        max_h = float( gconfc.get_int('max_height', 300) )

        src_w = self.pixbuf.get_width() 
        src_h = self.pixbuf.get_height()

        if src_w / max_w > src_h / max_h:
            ratio = max_w / src_w
        else:
            ratio = max_h / src_h

        w = int( src_w * ratio + 0.4 );
        h = int( src_h * ratio + 0.4 );

        self.pixbuf = self.pixbuf.scale_simple( w, h, gtk.gdk.INTERP_BILINEAR )

    def rotate(self, orientation='1'):
        if orientation == '6':
            rotate = 270
        elif orientation == '8':
            rotate = 90
        else:
            return
        
        self.pixbuf = self.pixbuf.rotate_simple(rotate)

class MakeDirPhoto (MakePhoto):

    def prepare(self):
        path = self.method
        r = re.compile(r'\.(jpe?g|png|gif|bmp)$', re.IGNORECASE)

        for root, dirs, files in os.walk(path):
            for f in files:
                if r.search(f):
                    filename = os.path.join(root, f)
                    data = { 'url'      : 'file://' + filename,
                             'filename' : filename,
                             'title'    : f }
                    self.photos.append(data)
        self.total = len(self.photos)

    def get_photo(self):
        self.photo = random.choice(self.photos)
        self.make()

class MakeFlickrPhoto (MakePhoto):

    def prepare(self):
        api_key = gconfc.get_string('flickr/api_key')
        user_id = gconfc.get_string('flickr/user_id')

        if api_key == None or user_id == None:
            return

        self.cache_dir = '/tmp/gphotoframe-' + os.environ['USER'] + '/'
        if not os.access(self.cache_dir, os.W_OK):
            os.makedirs(self.cache_dir)

        url = 'http://api.flickr.com/services/rest/?'
        values = {'api_key' : api_key,
                  'user_id' : user_id,
                  'count'   : 50,
                  'method'  : self.method,
                  'format'  : 'json',
                  'extras'  : 'owner_name',
                  'nojsoncallback' : '1' }

        urlget = UrlGetWithProxy()
        d = urlget.getPage(url + urllib.urlencode(values))
        d.addCallback(self.prepare_cb)

    def prepare_cb(self,data):
        d = json.loads(data)

        self.total = len(d['photos']['photo'])
        for s in d['photos']['photo']:
            url = "http://farm%s.static.flickr.com/%s/%s_%s.jpg" % (
                s['farm'], s['server'], s['id'], s['secret'])
            page_url = "http://www.flickr.com/photos/%s/%s" % (
                s['owner'], s['id'])

            data = {'url'        : url,
                    'owner_name' : s['ownername'],
                    'owner'      : s['owner'],
                    'id'         : s['id'],
                    'title'      : s['title'],
                    'page_url'   : page_url}
            self.photos.append(data)

    def get_photo(self):
        self.photo = random.choice(self.photos)
        url = self.photo['url']
        self.photo['filename'] = self.cache_dir + url[ url.rfind('/') + 1: ]
        urlget = UrlGetWithProxy()
        d = urlget.downloadPage(str(url), self.photo['filename'])
        d.addCallback(self.make)

class MakeFSpotPhoto (MakePhoto):

    def __del__(self):
        self.db.close()

    def prepare(self):
        db_file = os.environ['HOME'] + '/.gnome2/f-spot/photos.db'
        self.db = sqlite3.connect(db_file) 
        self.photos = self.count()
        self.rnd = WeightedRandom(self.photos)

    def count(self):
        sql = 'SELECT COUNT(*) FROM photos'
        self.total = self.db.execute(sql).fetchone()[0]
        rate_list = []

        for rate in xrange(6):
            sql = 'SELECT COUNT(*) FROM photos WHERE rating=' + str(rate)
            total_in_this = self.db.execute(sql).fetchone()[0]

            tmp_list = TMP()
            tmp_list.name = rate
            tmp_list.total = float(total_in_this)
            tmp_list.weight = total_in_this / float(self.total) * (rate * 2 + 1)
            # tmp_list.weight = rate * 2 + 1
            rate_list.append(tmp_list)

        return rate_list

    def get_photo(self):
        rate = self.rnd()
        sql  = 'SELECT uri FROM photos WHERE rating=' + str(rate.name) + \
            ' ORDER BY random() LIMIT 1;'
        url  = self.db.execute(sql).fetchone()[0]
        file = url.replace('file://', '')
        title = url[ url.rfind('/') + 1: ]

        self.photo = { 'url' : url, 'rate' : rate.name, 
                       'filename' : file, 'title' : title }
        self.make()

class TMP(object):
    pass

######################################################################

class UrlGetWithProxy(object):

    def __init__(self):
        proxy = os.environ['http_proxy']
        scheme, host, port, path = client._parse(proxy)

        if host != "" and port != "":
            self.proxy_host = host
            self.proxy_port = port
            self.proxyOn = True
        else:
            self.proxyOn = False

    def getPage(self, url, contextFactory=None, *args, **kwargs):
        factory = client.HTTPClientFactory(url, *args, **kwargs)
        d = self._urlget(factory, url, file)
        return d

    def downloadPage(self, url, file, contextFactory=None, *args, **kwargs):
        factory = client.HTTPDownloader(url, file, *args, **kwargs)
        d = self._urlget(factory, url, file)
        return d

    def _urlget(self, factory, url, contextFactory=None, *args, **kwargs):
        scheme, host, port, path = client._parse(url)
        if self.proxyOn is True:
            host, port = self.proxy_host, self.proxy_port
            factory.path = url
        if scheme == 'https':
                from twisted.internet import ssl
                if contextFactory is None:
                    contextFactory = ssl.ClientContextFactory()
                reactor.connectSSL(host, port, factory, contextFactory)
        else:
            reactor.connectTCP(host, port, factory)
        return factory.deferred

class GConf(object):
    """Gconf"""

    def __init__(self):
        self.dir = "/apps/gphotoframe/"

        self.gconf = gconf.client_get_default()
        self.gconf.add_dir(self.dir[:-1], gconf.CLIENT_PRELOAD_NONE)
        self.gconf.notify_add (self.dir + "interval", self.key_interval_cb)

    def key_interval_cb(self, client, id, entry, data):
        # print "interval change!"
        pass

    def key_changed_callback(self, client, id, entry, data):
        if not entry.value:
            # print "none"
            pass
        else:
            print entry.value.type
            print entry.value.to_string()

    def set_int(self, key, val):
        #self.gconf.set(self.dir + key + '1', { 'type': 'int', 'value': val});
        return self.gconf.set_int(self.dir + key, val)

    def get_int(self, key, default = 0):
        val = self.gconf.get_int(self.dir + key)
        if val == 0 and default != 0:
            return default
        else:
            return val

    def set_string(self, key, val):
        return self.gconf.set_string(self.dir + key, val)

    def get_string(self, key):
        val = self.gconf.get_string(self.dir + key)
        return val

    def recursive_unset(self, key):
        self.gconf.recursive_unset(self.dir + key, 1)

    def all_entries (self, key):
        return self.gconf.all_entries(key)

    def all_dirs (self, key):
        return self.gconf.all_dirs(self.dir + key)

class WeightedRandom(object):
    '''Weighted Ramdom'''

    def __init__(self, list):
        self.list = list
        self.weight_list = []
        total_weight = sum(item.weight for item in list)
        # total_weight = sum(item.weight * item.total for item in list)
        accum_weight = 0.0
        for item in list:
            accum_weight += item.weight
            # accum_weight += item.weight * item.total
            self.weight_list.append( accum_weight / total_weight )

    def __call__(self):
        n = random.uniform(0, 1)
        item = bisect.bisect(self.weight_list, n)
        return self.list[item]

if __name__ == "__main__":
    gconfc = GConf()
    main  = PhotoFrame()
    photoliststore = PhotoListStore()

    reactor.run()
